j
regress(8, 1)
regress_l(8, 1)
max
min
bin
bins[5]
bins[6]
bins <- c(0, 2, 4, 6, 8)
mhat <- vector(length=10)
x_bins <- findInterval(x=x, vec=bins, rightmost.close=FALSE, left.open=FALSE)
for (i in 1:10) {
x_val <- x[i]
bin <- x_bins[i]
num <- sum(y[which(x_bins == bin)])
denom <- length(which(x_bins == bin))
mhat[i] <- num / denom
}
error <- y - mhat
regress_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
bin <- findInterval(x=xi, vec=bins, rightmost.close=FALSE, left.open=FALSE)
min <- bins[bin]
max <- min + 2
if (max == 10) {
num <- (min <= xj) & (xj <= max)
denom <- sum((min <= x) & (x <= max))
} else {
num <- (min <= xj) & (xj < max)
denom <- sum((min <= x) & (x < max))
}
}
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- regress_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
1/(10 - 2 * v + v_tilde) * sum(errors^2)
1/(length(x) - 10 + 5) * sum(error ^ 2)
regress_l(1, 1)
regress_l(1, 1)
bins <- c(0, 2, 4, 6, 8)
mhat <- vector(length=10)
x_bins <- findInterval(x=x, vec=bins, rightmost.close=FALSE, left.open=FALSE)
for (i in 1:10) {
x_val <- x[i]
bin <- x_bins[i]
num <- sum(y[which(x_bins == bin)])
denom <- length(which(x_bins == bin))
mhat[i] <- num / denom
}
error <- y - mhat
regress_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
bin <- findInterval(x=xi, vec=bins, rightmost.close=FALSE, left.open=FALSE)
min <- bins[bin]
max <- min + 2
if (max == 10) {
num <- (min <= xj) & (xj <= max)
denom <- sum((min <= x) & (x <= max))
} else {
num <- (min <= xj) & (xj < max)
denom <- sum((min <= x) & (x < max))
}
return(num / denom)
}
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- regress_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
1/(10 - 2 * v + v_tilde) * sum(errors^2)
1/(length(x) - 10 + 5) * sum(error ^ 2)
kernel_mhat <- function(xi) {
true_x <- (x >= -1 + xi) & (x <= 1 + xi)
num <- sum(y[true_x])
denom <- sum(true_x)
return(num / denom)
}
kernel_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
num <- (xi - xj >= -1) & (xi - xj <= 1)
true_x <- (xi - x >= -1) & (xi - x <= 1)
denom <- sum(true_x)
return(num / denom)
}
pred_val <- unlist(lapply(x, FUN=kernel_mhat))
errors <- y - pred_val
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- kernel_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
sigma2 <- 1/(10 - 2 * v + v_tilde) * sum(errors^2)
sigma2
bins <- c(0, 2, 4, 6, 8)
mhat <- vector(length=10)
x_bins <- findInterval(x=x, vec=bins, rightmost.close=FALSE, left.open=FALSE)
for (i in 1:10) {
x_val <- x[i]
bin <- x_bins[i]
num <- sum(y[which(x_bins == bin)])
denom <- length(which(x_bins == bin))
mhat[i] <- num / denom
}
error <- y - mhat
regress_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
bin <- findInterval(x=xi, vec=bins, rightmost.close=FALSE, left.open=FALSE)
min <- bins[bin]
max <- min + 2
if (max == 10) {
num <- (min <= xj) & (xj <= max)
denom <- sum((min <= x) & (x <= max))
} else {
num <- (min <= xj) & (xj < max)
denom <- sum((min <= x) & (x < max))
}
return(num / denom)
}
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- regress_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
1/(10 - 2 * v + v_tilde) * sum(errors^2)
1/(8) * sum(error ^ 2)
10 - 2 - 1
bins <- c(0, 2, 4, 6, 8)
mhat <- vector(length=10)
x_bins <- findInterval(x=x, vec=bins, rightmost.close=FALSE, left.open=FALSE)
for (i in 1:10) {
x_val <- x[i]
bin <- x_bins[i]
num <- sum(y[which(x_bins == bin)])
denom <- length(which(x_bins == bin))
mhat[i] <- num / denom
}
error <- y - mhat
regress_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
bin <- findInterval(x=xi, vec=bins, rightmost.close=FALSE, left.open=FALSE)
min <- bins[bin]
max <- min + 2
if (max == 10) {
num <- (min <= xj) & (xj <= max)
denom <- sum((min <= x) & (x <= max))
} else {
num <- (min <= xj) & (xj < max)
denom <- sum((min <= x) & (x < max))
}
return(num / denom)
}
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- regress_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
1/(10 - 2 * v + v_tilde) * sum(errors^2)
1/(7) * sum(error ^ 2)
10 - 2 * v + v_tilde
bins <- c(0, 2, 4, 6, 8)
mhat <- vector(length=10)
x_bins <- findInterval(x=x, vec=bins, rightmost.close=FALSE, left.open=FALSE)
for (i in 1:10) {
x_val <- x[i]
bin <- x_bins[i]
num <- sum(y[which(x_bins == bin)])
denom <- length(which(x_bins == bin))
mhat[i] <- num / denom
}
error <- y - mhat
regress_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
bin <- findInterval(x=xi, vec=bins, rightmost.close=FALSE, left.open=FALSE)
min <- bins[bin]
max <- min + 2
if (max == 10) {
num <- (min <= xj) & (xj <= max)
denom <- sum((min <= x) & (x <= max))
} else {
num <- (min <= xj) & (xj < max)
denom <- sum((min <= x) & (x < max))
}
return(num / denom)
}
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- regress_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
1/(10 - 2 * v + v_tilde) * sum(error^2)
1/(length(x) - 10 + 5) * sum(error ^ 2)
sigam2 <- 1/(10 - 2 * v + v_tilde) * sum(error^2)
bins <- c(0, 2, 4, 6, 8)
mhat <- vector(length=10)
x_bins <- findInterval(x=x, vec=bins, rightmost.close=FALSE, left.open=FALSE)
for (i in 1:10) {
x_val <- x[i]
bin <- x_bins[i]
num <- sum(y[which(x_bins == bin)])
denom <- length(which(x_bins == bin))
mhat[i] <- num / denom
}
error <- y - mhat
regress_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
bin <- findInterval(x=xi, vec=bins, rightmost.close=FALSE, left.open=FALSE)
min <- bins[bin]
max <- min + 2
if (max == 10) {
num <- (min <= xj) & (xj <= max)
denom <- sum((min <= x) & (x <= max))
} else {
num <- (min <= xj) & (xj < max)
denom <- sum((min <= x) & (x < max))
}
return(num / denom)
}
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- regress_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
sigma <- 1/(10 - 2 * v + v_tilde) * sum(error^2)
bins <- c(0, 2, 4, 6, 8)
mhat <- vector(length=10)
x_bins <- findInterval(x=x, vec=bins, rightmost.close=FALSE, left.open=FALSE)
for (i in 1:10) {
x_val <- x[i]
bin <- x_bins[i]
num <- sum(y[which(x_bins == bin)])
denom <- length(which(x_bins == bin))
mhat[i] <- num / denom
}
error <- y - mhat
regress_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
bin <- findInterval(x=xi, vec=bins, rightmost.close=FALSE, left.open=FALSE)
min <- bins[bin]
max <- min + 2
if (max == 10) {
num <- (min <= xj) & (xj <= max)
denom <- sum((min <= x) & (x <= max))
} else {
num <- (min <= xj) & (xj < max)
denom <- sum((min <= x) & (x < max))
}
return(num / denom)
}
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- regress_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
sigma2 <- 1/(10 - 2 * v + v_tilde) * sum(error^2)
bins <- c(0, 2, 4, 6, 8)
mhat <- vector(length=10)
x_bins <- findInterval(x=x, vec=bins, rightmost.close=FALSE, left.open=FALSE)
bmin <- 4
bmax <- 6
y_vals <- y[which(x[which(x < bmax)] >= bmin)]
x <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
y <- c(5, 11, 8, 15, 11, 20, 21, 15, 18, 25)
slr <- lm(y~x)
summary(slr)$coefficients[, 1] %*% c(1, 5.5)
bmin <- 4
bmax <- 6
y_vals <- y[which(x[which(x < bmax)] >= bmin)]
sum(y_vals) / length(y_vals)
bmin <- 4
bmax <- 6
y_vals <- y[which(x[which(x < bmax)] >= bmin)]
sum(y_vals) / length(y_vals)
bins <- c(0, 2, 4, 6, 8)
mhat <- vector(length=10)
x_bins <- findInterval(x=x, vec=bins, rightmost.close=FALSE, left.open=FALSE)
for (i in 1:10) {
x_val <- x[i]
bin <- x_bins[i]
num <- sum(y[which(x_bins == bin)])
denom <- length(which(x_bins == bin))
mhat[i] <- num / denom
}
error <- y - mhat
regress_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
bin <- findInterval(x=xi, vec=bins, rightmost.close=FALSE, left.open=FALSE)
min <- bins[bin]
max <- min + 2
if (max == 10) {
num <- (min <= xj) & (xj <= max)
denom <- sum((min <= x) & (x <= max))
} else {
num <- (min <= xj) & (xj < max)
denom <- sum((min <= x) & (x < max))
}
return(num / denom)
}
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- regress_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
sigma2 <- 1/(10 - 2 * v + v_tilde) * sum(error^2)
sigma2
x <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
y <- c(5, 11, 8, 15, 11, 20, 21, 15, 18, 25)
slr <- lm(y~x)
summary(slr)$coefficients[, 1] %*% c(1, 5.5)
kernel_mhat <- function(xi) {
true_x <- (x >= -1 + xi) & (x <= 1 + xi)
num <- sum(y[true_x])
denom <- sum(true_x)
return(num / denom)
}
kernel_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
num <- (xi - xj >= -1) & (xi - xj <= 1)
true_x <- (xi - x >= -1) & (xi - x <= 1)
denom <- sum(true_x)
return(num / denom)
}
pred_val <- unlist(lapply(x, FUN=kernel_mhat))
errors <- y - pred_val
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- kernel_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
sigma2 <- 1/(10 - 2 * v + v_tilde) * sum(errors^2)
sigma2
x <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
y <- c(5, 11, 8, 15, 11, 20, 21, 15, 18, 25)
slr <- lm(y~x)
summary(slr)$coefficients[, 1] %*% c(1, 5.5)
bins <- c(0, 2, 4, 6, 8)
mhat <- vector(length=10)
x_bins <- findInterval(x=x, vec=bins, rightmost.close=FALSE, left.open=FALSE)
for (i in 1:10) {
x_val <- x[i]
bin <- x_bins[i]
num <- sum(y[which(x_bins == bin)])
denom <- length(which(x_bins == bin))
mhat[i] <- num / denom
}
error <- y - mhat
regress_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
bin <- findInterval(x=xi, vec=bins, rightmost.close=FALSE, left.open=FALSE)
min <- bins[bin]
max <- min + 2
if (max == 10) {
num <- (min <= xj) & (xj <= max)
denom <- sum((min <= x) & (x <= max))
} else {
num <- (min <= xj) & (xj < max)
denom <- sum((min <= x) & (x < max))
}
return(num / denom)
}
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- regress_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
sigma2 <- 1/(10 - 2 * v + v_tilde) * sum(error^2)
sigma2
15 + 11 + 20 + 21
kernel_mhat <- function(xi) {
true_x <- (x >= -2 + xi) & (x <= 2 + xi)
num <- sum(y[true_x])
denom <- sum(true_x)
return(num / denom)
}
kernel_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
num <- (xi - xj >= -2) & (xi - xj <= 2)
true_x <- (xi - x >= -2) & (xi - x <= 2)
denom <- sum(true_x)
return(num / denom)
}
pred_val <- unlist(lapply(x, FUN=kernel_mhat))
errors <- y - pred_val
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- kernel_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
sigma2 <- 1/(10 - 2 * v + v_tilde) * sum(errors^2)
kernel_mhat(5.5)
sigma2
xi <- 5.5
true_x <- (x >= -2 + xi) & (x <= 2 + xi)
true_x
num <- sum(y[true_x])
denom <- sum(true_x)
num
67/4
kernel_mhat <- function(xi) {
true_x <- (x >= -2 + xi) & (x <= 2 + xi)
num <- sum(y[true_x])
denom <- sum(true_x)
return(num / denom)
}
kernel_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
num <- (xi - xj >= -2) & (xi - xj <= 2)
true_x <- (xi - x >= -2) & (xi - x <= 2)
denom <- sum(true_x)
return(num / denom)
}
pred_val <- unlist(lapply(x, FUN=kernel_mhat))
errors <- y - pred_val
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- kernel_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
sigma2 <- 1/(10 - 2 * v + v_tilde) * sum(errors^2)
kernel_mhat(5.5)
sigma2
L
bins <- c(0, 2, 4, 6, 8)
mhat <- vector(length=10)
x_bins <- findInterval(x=x, vec=bins, rightmost.close=FALSE, left.open=FALSE)
for (i in 1:10) {
x_val <- x[i]
bin <- x_bins[i]
num <- sum(y[which(x_bins == bin)])
denom <- length(which(x_bins == bin))
mhat[i] <- num / denom
}
error <- y - mhat
regress_l <- function(i, j) {
xi <- x[i]
xj <- x[j]
bin <- findInterval(x=xi, vec=bins, rightmost.close=FALSE, left.open=FALSE)
min <- bins[bin]
max <- min + 2
if (max == 10) {
num <- (min <= xj) & (xj <= max)
denom <- sum((min <= x) & (x <= max))
} else {
num <- (min <= xj) & (xj < max)
denom <- sum((min <= x) & (x < max))
}
return(num / denom)
}
L <- matrix(NA, nrow=10, ncol=10)
for (i in 1:10) {
for (j in 1:10) {
L[i, j] <- regress_l(i, j)
}
}
v <- sum(diag(L))
v_tilde <- sum(diag(L %*% t(L)))
sigma2 <- 1/(10 - 2 * v + v_tilde) * sum(error^2)
L
sum(diag(L))
